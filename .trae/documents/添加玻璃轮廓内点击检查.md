## 添加玻璃范围坐标检查

### 问题分析
用户要求简化方案，只需要判断坐标是否超过玻璃范围，超过就舍去不需要记录。当前点击事件没有检查坐标范围，导致在玻璃外部点击也会标记缺陷。

### 解决方案
修改`d:\DEV\Code\JamesRepo\mac-insp\mac-inspection\frontend\src\components\CanvasStage.vue`文件，添加简单的坐标范围检查，只有在玻璃范围内的点击才会被处理。

### 具体修改点

1. **玻璃范围定义**：
   - 宽度：920mm = 920000um，X范围：-460000um 到 460000um
   - 高度：730mm = 730000um，Y范围：-365000um 到 365000um
   - 忽略倒角细节，使用简单矩形范围

2. **在`handleStageDown`函数中添加检查**：
   - 获取点击位置的物理坐标
   - 判断是否在玻璃范围内
   - 只有在范围内才继续处理点击事件
   - 外部点击直接返回

3. **在`handleStageUp`函数中添加检查**：
   - 检查绘制开始点是否在玻璃范围内
   - 确保只有在范围内的绘制才会被保存

4. **调试信息**：
   - 添加坐标范围检查的调试日志
   - 输出点击位置和是否在范围内的结果

### 修改策略
- 采用简单的矩形范围判断
- 忽略倒角细节，简化计算
- 只检查X和Y坐标是否在范围内
- 保持代码简洁和高效

### 预期效果
- 只有在玻璃范围内的点击才会标记缺陷
- 外部点击被忽略，不产生任何效果
- 保持原有功能不变
- 代码简洁高效
- 便于调试和维护

### 关键代码实现
```javascript
// 在handleStageDown函数中添加检查
const handleStageDown = (e) => {
  // ... 现有代码 ...
  
  const pos = stage.getPointerPosition();
  const physX = toPhysical(pos.x - stage.width()/2);
  const physY = toPhysicalY(pos.y - stage.height()/2);
  
  // 简单坐标范围检查（忽略倒角，使用矩形范围）
  const halfW = glassConfig.size.w / 2;
  const halfH = glassConfig.size.h / 2;
  if (Math.abs(physX) > halfW || Math.abs(physY) > halfH) {
    console.log('点击位置在玻璃外部，忽略操作:', physX/1000, 'mm,', physY/1000, 'mm');
    return;
  }
  
  // ... 继续处理内部点击 ...
};

// 在handleStageUp函数中添加检查
const handleStageUp = () => {
  // ... 现有代码 ...
  
  const pts = drawingState.points;
  if (pts.length < 1) return;
  
  // 检查绘制开始点是否在玻璃范围内
  const startPt = pts[0];
  const halfW = glassConfig.size.w / 2;
  const halfH = glassConfig.size.h / 2;
  if (Math.abs(startPt.x) > halfW || Math.abs(startPt.y) > halfH) {
    console.log('绘制开始点在玻璃外部，忽略操作:', startPt.x/1000, 'mm,', startPt.y/1000, 'mm');
    drawingState.points = [];
    if (drawingState.tempLine) {
      drawingState.tempLine.destroy();
      drawingState.tempLine = null;
    }
    return;
  }
  
  // ... 继续处理内部绘制 ...
};
```