## 优化曲线、面缺类型的绘制逻辑

### 问题分析
当前代码中，曲线、面缺类型的绘制逻辑存在问题：
1. 当用户只是点击一下图形（移动距离很小），就会生成无效的路径
2. 后端保存时会报错：`A linearring requires at least 4 coordinates.`
3. 需要优化：如果线缺、曲线、面缺鼠标移动距离小于2mm，就不做响应

### 解决方案
修改`d:\DEV\Code\JamesRepo\mac-insp\mac-inspection\frontend\src\components\CanvasStage.vue`文件，在`handleStageUp`函数中添加移动距离检查，过滤掉移动距离过小的绘制操作。

### 具体修改点

1. **添加移动距离检查函数**：
   - 实现`getDistance`函数，计算两点之间的距离
   - 支持物理坐标和屏幕坐标
   - 返回距离（单位：um）

2. **在`handleStageUp`函数中添加距离检查**：
   - 区分不同缺陷类型的阈值
   - 线缺（LINE）：检查起点和终点距离
   - 曲线（CURVE）：检查总移动距离
   - 面缺（REGION/AREA）：检查总移动距离
   - 移动距离小于2mm（2000um）时，不保存缺陷

3. **阈值设置**：
   - 线缺：最小2mm
   - 曲线：最小2mm
   - 面缺：最小2mm
   - 可根据实际需求调整

4. **清除无效绘制**：
   - 移动距离过小时，清除临时绘制
   - 重置绘制状态
   - 不触发`add-defect`事件

5. **调试信息**：
   - 添加距离检查的调试日志
   - 输出移动距离和阈值
   - 便于调试和验证

### 修改策略
- 先实现`getDistance`辅助函数
- 再修改`handleStageUp`函数，添加距离检查
- 区分不同类型的缺陷处理
- 保持代码简洁和高效

### 预期效果
- 线缺、曲线、面缺类型的绘制需要至少2mm的移动距离
- 点击一下不会生成无效路径
- 避免后端保存时的报错
- 提升用户体验
- 便于调试和维护

### 关键代码实现
```javascript
// 辅助函数：计算两点之间的距离（单位：um）
const getDistance = (x1, y1, x2, y2) => {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
};

// 在handleStageUp函数中添加距离检查
const handleStageUp = () => {
  // ... 现有代码 ...
  
  const pts = drawingState.points;
  if (pts.length < 1) return;
  
  // ... 现有代码：检查玻璃范围 ...
  
  const code = props.selectedCode;
  const type = code.type?.toUpperCase();
  const minDistance = 2000; // 2mm = 2000um
  
  // 检查移动距离
  if (type === 'LINE') {
    // 线缺：检查起点和终点距离
    const start = pts[0];
    const endX = toPhysical(stage.getPointerPosition().x - stage.width()/2);
    const endY = toPhysicalY(stage.getPointerPosition().y - stage.height()/2);
    const distance = getDistance(start.x, start.y, endX, endY);
    
    if (distance < minDistance) {
      console.log(`线缺移动距离过小（${distance/1000}mm < 2mm），忽略操作`);
      drawingState.points = [];
      return;
    }
  } else if (type === 'CURVE' || type === 'REGION' || type === 'AREA') {
    // 曲线、面缺：检查总移动距离
    if (pts.length < 2) {
      console.log(`${type}绘制点过少，忽略操作`);
      drawingState.points = [];
      return;
    }
    
    let totalDistance = 0;
    for (let i = 1; i < pts.length; i++) {
      const prev = pts[i-1];
      const curr = pts[i];
      totalDistance += getDistance(prev.x, prev.y, curr.x, curr.y);
    }
    
    if (totalDistance < minDistance) {
      console.log(`${type}总移动距离过小（${totalDistance/1000}mm < 2mm），忽略操作`);
      drawingState.points = [];
      return;
    }
  }
  
  // ... 继续处理有效绘制 ...
};
```