# 修复对称点提示清除时机问题

## 问题分析
1. 之前在`redrawVisibleDefects`函数中添加清除对称点提示的代码，导致每次添加新缺陷时，对称点提示刚显示就被清除
2. 原因：点击mask缺陷添加新缺陷时，会触发`currentDefects`更新，进而调用`redrawVisibleDefects`函数，清除了刚刚显示的对称点提示
3. 需要找到一个只在切换glassid时执行，但在添加新缺陷时不执行的时机

## 解决方案
1. 在父组件`InspectionView.vue`中，将`currentGlassId`作为prop传递给子组件`CanvasStage`
2. 在子组件`CanvasStage.vue`中，添加watch监听`currentGlassId`的变化
3. 当`currentGlassId`变化时，清除对称点提示
4. 同时保留对`selectedCode`的watch监听，确保切换缺陷类型时也能清除对称点提示

## 实现步骤

### 1. 修改父组件`InspectionView.vue`
在`CanvasStage`组件中添加`current-glass-id` prop：
```html
<CanvasStage 
  :selected-code="selectedCode" 
  :current-defects="visibleDefects"
  :defect-codes="defectCodes"
  :selected-product-id="selectedInfo.product"
  :readonly="isReadonly"
  :current-glass-id="currentGlassId"
  @add-defect="addDefect"
  @layout-status-change="hasLayout = $event"
/>
```

### 2. 修改子组件`CanvasStage.vue`
- 在props中添加`currentGlassId`
- 添加watch监听`currentGlassId`的变化
- 确保watch监听`selectedCode`的变化也能清除对称点提示

```javascript
// 添加props
const props = defineProps({
  // 原有props...
  currentGlassId: { type: String, default: '' }
});

// 监听currentGlassId变化，清除对称点提示
watch(() => props.currentGlassId, () => {
  if (hintLayer) {
    hintLayer.destroyChildren();
    hintLayer.draw();
  }
}, { immediate: false });

// 保留原有监听selectedCode的watch
watch(() => props.selectedCode, () => {
  if (hintLayer) {
    hintLayer.destroyChildren();
    hintLayer.draw();
  }
}, { immediate: false });
```

## 代码修改点

1. **InspectionView.vue**：
   - 为`CanvasStage`组件添加`current-glass-id` prop

2. **CanvasStage.vue**：
   - 在props中添加`currentGlassId`
   - 添加watch监听`currentGlassId`的变化，清除对称点提示
   - 保留原有监听`selectedCode`的watch

## 预期效果
- 切换glassid时，当前glass上的对称点提示会被清除
- 切换缺陷类型时，当前显示的对称点提示会被清除
- 点击mask缺陷添加新缺陷时，对称点提示不会被清除，能够正常显示
- 点击新缺陷时，旧的对称点提示会被清除

## 验证步骤
1. 运行`npm run build`命令，确保构建成功
2. 运行`npm run dev`命令，确保开发服务器成功启动
3. 测试切换glassid时，对称点提示是否被清除
4. 测试切换缺陷类型时，对称点提示是否被清除
5. 测试点击mask缺陷时，对称点提示是否能够正常显示，不会被立即清除
6. 测试点击新缺陷时，旧的对称点提示是否被清除